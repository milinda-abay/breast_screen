ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = ''))
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs)
data_path <- "M:/Documents/@Projects/BCS/data/PBI Indicators/"
ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = ''))
ind2_rescreen
ind2_rescreen[, `AGE GROUP (YEARS)` := gsub('â€“', '-', `AGE GROUP (YEARS)`)]
fwrite(ind2_rescreen, 'ind2_rescreenx.csv')
fwrite(ind2_rescreen, paste(data_path,'ind2_rescreenx.csv'))
fwrite(ind2_rescreen, paste(data_path,'Rescreening_2.csv'))
ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = ''))
rm(ind2_rescreen, envir = as.environment(".GlobalEnv"))
ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = ''))
ind2_rescreen[, `AGE GROUP (YEARS)` := gsub('â€“', '-', `AGE GROUP (YEARS)`)]
fwrite(ind2_rescreen, paste(data_path,'Rescreening_2.csv'))
rm(ind2_rescreen, envir = as.environment(".GlobalEnv"))
ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = ''))
ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = ''))
data_path <- "M:/Documents/@Projects/BCS/data/PBI Indicators/"
ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = ''))
ind2_rescreen[, `AGE GROUP (YEARS)` := gsub('â€“', '-', `AGE GROUP (YEARS)`)]
ind2_rescreen <- clean_up_indicator_2345(ind2_rescreen)
ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = '')) ind3_recall <- fread(paste(data_path, 'Recall_3.csv', sep = '')) ind4_cancer <- fread(paste(data_path, 'Cancer_4.csv', sep = ""))
ind5_dcis <- clean_up_indicator_2345(ind5_dcis)
ind5_dcis <- fread(paste(data_path, 'DCIS_5.csv', sep = ''))
clean_up_indicator_2345 <- function(DT) {     # all ages 70+  considered 70-85     # all ages 75+ considered 75-85     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '-', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '70+', `AGE GROUP (YEARS)` := '70–85']     DT[`AGE GROUP (YEARS)` == '75+', `AGE GROUP (YEARS)` := '75–85']     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)]     DT[, list(age = seq(from= l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)] }
ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = '')) ind3_recall <- fread(paste(data_path, 'Recall_3.csv', sep = '')) ind4_cancer <- fread(paste(data_path, 'Cancer_4.csv', sep = "")) ind5_dcis <- fread(paste(data_path, 'DCIS_5.csv', sep = ''))
data_path <- "M:/Documents/@Projects/BCS/data/PBI Indicators/"
ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = '')) ind3_recall <- fread(paste(data_path, 'Recall_3.csv', sep = '')) ind4_cancer <- fread(paste(data_path, 'Cancer_4.csv', sep = "")) ind5_dcis <- fread(paste(data_path, 'DCIS_5.csv', sep = ''))
ind2_rescreen <- clean_up_indicator_2345(ind2_rescreen)
ind3_recall <- clean_up_indicator_2345(ind3_recall)
ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = ''))
ind2_rescreen <- clean_up_indicator_2345(ind2_rescreen)
clean_up_indicator_2345 <- function(DT) {     # all ages 70+  considered 70-85     # all ages 75+ considered 75-85     browser()     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '-', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '70+', `AGE GROUP (YEARS)` := '70–85']     DT[`AGE GROUP (YEARS)` == '75+', `AGE GROUP (YEARS)` := '75–85']     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)]     DT[, list(age = seq(from= l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)] }
ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = ''))
ind2_rescreen <- clean_up_indicator_2345(ind2_rescreen)
    DT[, `AGE GROUP (YEARS)` := gsub('â€“', '-', `AGE GROUP (YEARS)`)]
    DT[`AGE GROUP (YEARS)` == '70+', `AGE GROUP (YEARS)` := '70–85']
    DT[`AGE GROUP (YEARS)` == '75+', `AGE GROUP (YEARS)` := '75–85']
    DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]
Q
ind2_rescreen <- fread(paste(data_path, 'Rescreening_2.csv', sep = ''))
clean_up_indicator_2345 <- function(DT) {     # all ages 70+  considered 70-85     # all ages 75+ considered 75-85     browser()     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '70+', `AGE GROUP (YEARS)` := '70–85']     DT[`AGE GROUP (YEARS)` == '75+', `AGE GROUP (YEARS)` := '75–85']     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)]     DT[, list(age = seq(from= l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)] }
ind2_rescreen <- clean_up_indicator_2345(ind2_rescreen)
    DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]
    DT[`AGE GROUP (YEARS)` == '70+', `AGE GROUP (YEARS)` := '70–85']
    DT[`AGE GROUP (YEARS)` == '75+', `AGE GROUP (YEARS)` := '75–85']
    DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]
    DT[, c('AGE GROUP (YEARS)') := NULL]
    DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)]
    DT[, list(age = seq(from= l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, calculated_mean)]
DT[, , by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
DT[, l_age , by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
DT[, .(l_age, u_age) , by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
DT
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
DT
    DT[, list(age = seq(from = 40, to = 44)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, list(age = seq(from = l_age, to = 44)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
clean_up_indicator_1 <- function(DT) {     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–100'] # all 85+ year old women considered 85-100     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[Period %like% '-', Period := gsub('-', '–', Period)]     DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('Mean_1') := NUM_WOMEN / (u_period - l_period + 1)]     DT[DT, Mean_2 := i.Mean_1, on = c(l_period = 'u_period', 'STATE', 'l_age', 'u_age')]     DT[, calculated_mean := rowMeans(DT[, .(Mean_1, Mean_2)], na.rm = TRUE)]     DT[, c('AGE GROUP (YEARS)', 'Period', 'Mean_1', 'Mean_2') := NULL]     DT[, calculated_mean := calculated_mean / (u_age - l_age + 1)]     browser()     DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, l_period, calculated_mean)] }
clean_up_indicator_1 <- function(DT) {     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–100'] # all 85+ year old women considered 85-100     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[Period %like% '-', Period := gsub('-', '–', Period)]     DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('Mean_1') := NUM_WOMEN / (u_period - l_period + 1)]     DT[DT, Mean_2 := i.Mean_1, on = c(l_period = 'u_period', 'STATE', 'l_age', 'u_age')]     DT[, calculated_mean := rowMeans(DT[, .(Mean_1, Mean_2)], na.rm = TRUE)]     DT[, c('AGE GROUP (YEARS)', 'Period', 'Mean_1', 'Mean_2') := NULL]     DT[, calculated_mean := calculated_mean / (u_age - l_age + 1)]     browser()     DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, l_period, calculated_mean)] }
ind1_participation <- fread(paste(data_path, 'Participation_1.csv', sep = ''))
ind1_participation <- clean_up_indicator_1(ind1_participation)
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R')
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, l_period, calculated_mean)]
c
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]
    DT[`AGE GROUP (YEARS)` == '70+', `AGE GROUP (YEARS)` := '70–85']
    DT[`AGE GROUP (YEARS)` == '75+', `AGE GROUP (YEARS)` := '75–85']
    DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]
    DT[, c('AGE GROUP (YEARS)') := NULL]
    DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R')
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, l_period, calculated_mean)]
DT
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, l_period, u_period, calculated_mean)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, l_period, calculated_mean)]
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs)
source('load_data.R')
    DT
c
    DT
    DT[, list(age = seq(from = l_age, to = u_age))]
    DT[, l_age]
    DT[, l_age, by = .(NUM_WOMNE)]
    DT[, l_age, by = .(NUM_WOMEN)]
DT
    DT[, seq(from = l_age, to = u_age), by = .(NUM_WOMEN)]
    DT[, l_age, by = .(NUM_WOMEN, Period)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, l_period, calculated_mean)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, Period, calculated_mean)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, u_age,calculated_mean)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, l_age,calculated_mean)]
DT
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, length(l_age), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, length(u_age), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, lage = seq(from = l_age, to = u_age), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, age = seq(from = l_age, to = u_age), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, seq(from = l_age, to = u_age), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean, l_age)]
Q
source('load_data.R')
traceback()
source('load_data.R')
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs)
source('load_data.R')
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, l_period, calculated_mean)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, calculated_mean)]
DT
c
c
DT
DT[, Period]
DT[, .Period]
DT[, .(Period)]
DT[, .(Period), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN,  Screen, STATE, calculated_mean, l_age)]
DT[, .(Period), by = .(NUM_WOMEN, Screen, STATE, calculated_mean)]
DT[, .(l_age), by = .(NUM_WOMEN, Screen, STATE, calculated_mean)]
class(DT)
DT[, .(l_age), by = .(NUM_WOMEN, Screen, STATE, calculated_mean)]
DT[, .(x=l_age), by = .(NUM_WOMEN, Screen, STATE, calculated_mean)]
DT[, .(x=seq(from = l_age, to = l_age+4)), by = .(NUM_WOMEN, Screen, STATE, calculated_mean)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean, l_age)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Screen, STATE, calculated_mean)]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, calculated_mean)]
DT
Q
source('load_data.R')
df <- data.table(x = c('a', 'b', 'c'), y = c(4, 5, 6), from = c(1, 2, 3), to = c(2, 4, 6))
Q
df <- data.table(x = c('a', 'b', 'c'), y = c(4, 5, 6), from = c(1, 2, 3), to = c(2, 4, 6))
dt <- data.table(x = c('a', 'b', 'c'), y = c(4, 5, 6), from = c(1, 2, 3), to = c(2, 4, 6))
rm(df, envir = as.environment(".GlobalEnv"))
df[, .(exp = seq(from=from, to= to)), by = .(x,y)]
dt[, .(z = from:to), by = .(x, y)]
source('load_data.R')
DT[, .(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, l_period, calculated_mean)]
DT[, .(age = l_age:u_age), by = .(NUM_WOMEN, STATE, l_period, calculated_mean)]
DT[, .(age = l_age:u_age), by = .(NUM_WOMEN, STATE, calculated_mean)]
DT[, .(age = l_age,u_age), by = .(NUM_WOMEN, STATE, calculated_mean)]
DT[, .(age = .(l_age,u_age)), by = .(NUM_WOMEN, STATE, calculated_mean)]
DT
DT[, .(age = .(l_age,u_age)), by = .(NUM_WOMEN, STATE, calculated_mean, l_period)]
c
c
DT
DT, .(age=l_age:u_age), by =.(NUM_WOMEN, Period, Screen, STATE, calculated_mean)
DT, .(age=l_age:u_age), by =.(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
DT[, .(age=l_age:u_age), by =.(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R')
c
c
DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, calculated_mean)]
DT
DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
Q
ind4_cancer <- fread(paste(data_path, 'Cancer_4.csv', sep = ""))
ind4_cancer <- clean_up_indicator_2345(ind4_cancer)
c
ind4_cancer <- fread(paste(data_path, 'Cancer_4.csv', sep = ""))
ind4_cancer <- clean_up_indicator_2345(ind4_cancer)
c
ind4_cancer
dt <- data.table(x = c('a', 'b', 'c'), y = c(4, 5, 6), from = c(1, 2, 3), to = c(2, 4, 6))
dt[, .(z = from:to), by = .(x, y)]
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs)
source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R')
DT
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, STATE, l_period, calculated_mean)]
c
c
DT
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, STATE, calculated_mean)]
    DT[, length(l_age), by = .(NUM_WOMEN, Period, STATE, calculated_mean)]
    x <- DT
x[ Period == 2006]
x[ Period == 2006 && NUM_WOMEN == 3]
x[ Period == 2006 && NUM_WOMEN == 3,]
x[ Period == 2006 & NUM_WOMEN == 3,]
DT[, length(l_age), by = .(NUM_WOMEN, Period, STATE, calculated_mean)]
DT[, length(l_age), by = .(NUM_WOMEN, Period, STATE, calculated_mean)][V1 > 1]
DT[, length(l_age), by = .N][V1 > 1]
DT[, length(l_age), by = .N]
DT[, l_age, by = .N]
DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
DT[, list(age = seq(from = l_age, to = u_age)), by = .N]
DT[, length(l_age), by = .(NUM_WOMEN, Period, STATE, calculated_mean)][V1 > 1]
DT
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
DT[, length(l_age), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)][V1 > 1]
DT
DT[, , by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
DT[ NUM_WOMEN==39, , ]
DT[NUM_WOMEN == 39 || NUM_WOMEN == 15,,]
DT[NUM_WOMEN == 39 | NUM_WOMEN == 15,,]
DT[NUM_WOMEN == 39 | NUM_WOMEN == 15 & STATE =='NT',,]
DT[(NUM_WOMEN == 39 | NUM_WOMEN == 15) & STATE =='NT',,]
DT[, length(l_age), by = .(NUM_WOMEN, Period, Screen, STATE, calculated_mean)][V1 > 1]
DT[, length(l_age), by = by = seq_len(nrow(DT))][V1 > 1]
DT[, length(l_age), by = seq_len(nrow(DT))][V1 > 1]
DT[, length(l_age), by = seq_len(nrow(DT))]
    DT[, list(age = seq(from = l_age, to = u_age)), by = seq_len(nrow(DT))]
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(seq_len(nrow(DT)), NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT[, seq_len := NULL]
DT
    DT[, list(age = seq(from = l_age, to = u_age)), by = .(seq_len(nrow(DT)), NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
    DT <- DT[, list(age = seq(from = l_age, to = u_age)), by = .(seq_len(nrow(DT)), NUM_WOMEN, Period, Screen, STATE, calculated_mean)]
DT
    DT[, seq_len := NULL]
    DT
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R')
c
c
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'MM' cycles <- 8
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R')
object_creator <- create_objects(state_names)
#Create a list of values for the transition matrix
baseline_arglist <- object_creator$create_argument_list()
baseline_arglist$load_list('baseline_tmatrix')
#Create the transition matrix
baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values())
# Create a list of model states
state_list <- object_creator$create_states(state_names, a=x, b=y, c=z)
# Initialise 
cur_I <- NULL
cur_BC <- NULL
cur_RC <- NULL
cur_EB <- NULL
cur_ER <- NULL
cur_ET <- NULL
cur_KB <- NULL
cur_KR <- NULL
cur_KT <- NULL
cur_SN <- NULL
cur_SP <- NULL
cur_POS <- NULL
cur_PPC = NULL
flow_cost <- rep(1,12)
state_cost <- rep(10, 12)
utility <- rep(1, 12)
# Creates an unevaluated set of parameters
parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               )
# POS - probability of screening
# PPC - probability of presenting clinically
# Create and initialise inputs
winter_input_dt <- ind1_participation[, (state_names) := 0]
winter_input_dt[ , NoBC := calculated_mean]
# TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't
# matter, e.g. s2_strategey$properties$...
baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     )
# TODO - define_initialisation is extremely bespoke. More thought must be given to make it
# a generic method
class(baseline_strategy)
start_year <- 2008
init <- winter_input_dt[l_period == start_year]
test <- 'MM'
cycles <- 8
library(deSolve) # You first need to install this package if not already done ## Build an SIR model sir <- function(time, state, parameters) {     with(as.list(c(state, parameters)), {         dS <- -beta * S * I         dI <- beta * S * I - gamma * I         dR <- gamma * I         return(list(c(dS, dI, dR)))     }) } ## Just an example using the SIR model run_a_simulation <- function(parameters) {     ### Set parameters     init <- c(S = 1 - 1e-5, I = 1e-5, R = 0.0)     ## Time frame     times <- seq(0, 50, by = 0.1)     ## Solve using ode (General Solver for Ordinary Differential Equations)     out <- ode(y = init, times = times, func = sir, parms = parameters)     ## change to data frame     out <- as.data.frame(out)     return(out) } plot_results <- function(outputs) {     x11() # open a window for the plot     par(lwd = 3) # line-width option     plot(outputs$time, outputs$I, col = 'red', type = 'l', xlim = c(0, 50), ylim = c(0, 1), xlab = 'time', ylab = 'compartment proportions')     lines(outputs$time, outputs$S, col = 'green')     lines(outputs$time, outputs$R, col = 'blue') } metropolis_hastings <- function(log_lh_func, log_priors_func, proposal_func, init_params, n_accepted, max_iterations = 1e4) {     # log_lh_func: a function returning the log-likelihood value. This is log( P(data | theta) )     # priors_func: a function returning the joint prior log-likelihood of the parameters. This is  log( P(theta) )     # proposal_func (or jumping function): a function returning a new parameter set, starting from another parameter set. P(theta' | theta)     # init_params: a list containing the parameters. e.g list(beta=0.5, gamma=2.6)     # n_accepted: number of accepted runs     # max_iterations: maximum number of iterations allowed     # preliminary check: max_iterations has to be >= n_accepted     stopifnot(max_iterations >= n_accepted)     # prepare storage for the results. columns will be named "log_lh", "accepted", "param1", "param2", ...     results = data.frame(log_lh = double(), accepted = integer())     for (param_name in names(init_params)) {         results[[param_name]] = double()     }     # initialise counters     count_iterations = 0     count_accepted = 0     # calculate the likelihoods of the initial parameter set     current_params = init_params # current_params is the last accepted set of paramaters      current_log_lh = log_lh_func(init_params)     current_log_prior = log_priors_func(init_params)     while (count_accepted < n_accepted) {         if (count_iterations >= max_iterations) {             print("The maximum number of iterations has been reached. The simulation has been aborted.")             break         }         # Generate a new candidate parameter set         proposed_params = proposal_func(current_params)         # Evaluate the likelihood of the new parameter set         proposed_log_lh = log_lh_func(proposed_params)         proposed_log_prior = log_priors_func(proposed_params)         # Acceptance or rejection?         accepted = 0         log_proba_of_acceptance = proposed_log_prior + proposed_log_lh - (current_log_prior + current_log_lh) # we could have stored (current_log_prior + current_log_lh) in a variable         proba_of_acceptance = exp(log_proba_of_acceptance) # transform to actual proba         if (proba_of_acceptance >= 1) {             # the proposed parameter set is "better" than the current one             accepted = 1         } else {             accepted = rbinom(n = 1, size = 1, prob = proba_of_acceptance)         }         # storage         new_row = list(log_lh = proposed_log_lh + proposed_log_prior, accepted = accepted)         for (param_name in names(proposed_params)) {             new_row[[param_name]] = proposed_params[[param_name]]         }         results = rbind(results, new_row)         # If the run is accepted, we update the relevant variables         if (accepted == 1) {             current_params = proposed_params             current_log_prior = proposed_log_prior             current_log_lh = proposed_log_lh             count_accepted = count_accepted + 1         }         count_iterations = count_iterations + 1     }     # post-simulation calculation of acceptance ratio.      acceptance_ratio = count_accepted / count_iterations     print(paste('Acceptance ratio:', acceptance_ratio, sep = ' '))     return(results) } my_log_lh_func <- function(params) {     # params is a list of parameters and associated values.     # return the likelihood value associated with the parameter set.     # run the SIR model with the input parameters     sir_results = run_a_simulation((params))     # Our likelihood is obtained by multiplying Gaussian elements centered on the model estimate for each datapoint.     # We assume that the standard deviation is 0.05. This means that 95% of the Gaussian dentisty sits within an      # interval of width 0.1 (2*sd).     sd = 0.05     overall_log_lh = 0     for (i in 1:nrow(my_data)) {         # for each date of the dataset         model_output = sir_results$I[sir_results$time == my_data$date[i]]         browser()         single_log_lh = dnorm(x = my_data$in_bed[i], mean = model_output, sd = sd, log = TRUE)         overall_log_lh = overall_log_lh + single_log_lh     }     return(overall_log_lh) } my_log_priors_func <- function(params) {     # params is a list of parameters and associated values     # this funciton returns the joint prior distribution (actually log version)     joint_log_prior = 0     for (param_name in names(params)) {         if (param_name == "beta") {             # flat prior             y = dunif(x = params[[param_name]], min = 0, max = 10, log = TRUE)         } else if (param_name == "gamma") {             # beta distribution on interval [0,1]             y = dbeta(x = params[[param_name]], shape1 = 2, shape2 = 2, log = TRUE)         }         joint_log_prior = joint_log_prior + y     }     return(joint_log_prior) } my_proposal_func <- function(params) {     # params is a list of parameters and associated values     # this function returns another list of parameters     # We use normal distributions to generate new parameter values     # standard deviations     sd = list(beta = 0.02, gamma = 0.02)     new_params = list()     for (param_name in names(params)) {         new_value = -1         while (new_value < 0) {             # we want the parameter value to be positive             new_value = params[[param_name]] + rnorm(n = 1, mean = 0, sd = sd[[param_name]])         }         new_params[[param_name]] = new_value     }     return(new_params) } master_mcmc_runner <- function(n_accepted = 100) {     init_params = list(beta = 1.0, gamma = 0.5)     M = metropolis_hastings(log_lh_func = my_log_lh_func, log_priors_func = my_log_priors_func, proposal_func = my_proposal_func, init_params = init_params, n_accepted = n_accepted)     return(M) } ## beta: infection parameter; gamma: recovery parameter # Run the code below for an example simulation. # parameters = list(beta = 1.0, gamma = 0.5) # output = run_a_simulation((parameters)) # plot_results(output) library(outbreaks) # load outbreak datasets my_data = influenza_england_1978_school # influenza outbreak in a boarding school total_population = 763 # population of the boarding school # rearrange the data by turning dates into numbers my_data$date = as.numeric(my_data$date) # The index case (not included in the dataset) was infected on 10-01-1978. data starts on 22-01-1978 # Then the first date of the dataset will have index 12. adjustment = my_data$date[1] - 12 my_data$date = my_data$date - adjustment # normalise prevalence data my_data$in_bed = my_data$in_bed / total_population plot_data <- function() {     x11() # open a new window     plot(my_data$date, my_data$in_bed, xlim = c(0, 30)) } # create an outputs directory output_dir = "outputs/" dir.create(output_dir) # specify file format for figure outputs file_format = 'pdf' #  accepted values: 'pdf', 'png', 'jpeg' and 'jpg'. get_list_of_params <- function(mcmc_outputs) {     # automatically reads the list of parameter names from the mcmc output file     col_names = colnames(mcmc_outputs)     param_list = col_names[3:length(col_names)]     return(param_list) } open_figure_for_saving <- function(filename, format) {     # This function opens a file and prepare it for the specified format.     if (format == 'png') {         png(filename)     } else if (format == 'pdf') {         pdf(filename)     } else if (format == 'jpeg' || format == 'jpg') {         jpeg(filename)     } } plot_parameter_progressions <- function(mcmc_outputs, param_list, accepted_only = TRUE) {     # Plot the timeseries associated with the different parameters     for (param in param_list) {         filename = paste(output_dir, 'param_progress_', param, '.', file_format, sep = '')         open_figure_for_saving(filename, file_format)         # every plotting after this point will appear in the output file         par(pch = 20) # specify the point style for the figure         color_list = c('red', 'black') # black for accepted / red for rejected         cex_list = c(1, 1) # point size for rejected / accepted         if (accepted_only == TRUE) {             cex_list = c(0, 1) # point-size=0 will plot nothing         }         colors = color_list[mcmc_outputs$accepted + 1]         cexs = cex_list[mcmc_outputs$accepted + 1]         plot(mcmc_outputs[[param]], main = 'Pameter progression', ylab = param, ylim = range(mcmc_outputs[[param]]), col = colors, cex = cexs)         dev.off() # close the file     } } plot_log_likelihood_progression <- function(mcmc_outputs) {     # Represents the log-likelihood progression for the different iterations     filename = paste(output_dir, 'loglikelihood_progress.', file_format, sep = '')     open_figure_for_saving(filename, file_format)     par(pch = 20)     plot(mcmc_outputs$log_lh, main = 'Log-likelihood progression', ylab = 'log-likelihood')     dev.off() # close the file } plot_best_fit <- function(mcmc_outputs, param_list) {     # plot the maximum-likelihood model run and the datapoints     best_run_index = which.max(M$log_lh) # get best run     params = list()     for (param in param_list) {         params[[param]] = mcmc_outputs[[param]][best_run_index] # read associated parameter values     }     sir_results = run_a_simulation(params) # run the simulation     y_max = max(sir_results$I, my_data$in_bed) # get the highest value for plotting purpose      filename = paste(output_dir, 'best_fit.', file_format, sep = '')     open_figure_for_saving(filename, file_format)     plot(sir_results$time, sir_results$I, main = 'Best model fit', col = 'red', type = 'l', xlim = c(0, 50), ylim = c(0, y_max), xlab = 'time (days)', ylab = 'Infection prevalence')     lines(my_data$date, my_data$in_bed, type = 'p')     dev.off() } plot_posterior_distributions <- function(mcmc_outputs, param_list) {     # plot histograms for the posterior distributions of the parameters     for (param in param_list) {         filename = paste(output_dir, 'posterior_', param, '.', file_format, sep = '')         open_figure_for_saving(filename, file_format)         hist(mcmc_outputs[[param]][mcmc_outputs$accepted == 1], xlab = param, main = 'Posterior distribution')         dev.off() # close the file     } } plot_param_collinearity <- function(mcmc_outputs, param_list) {     # Produce scatter plots showing the relationships between every pair of parameters     filename = paste(output_dir, 'parameter_collinearity.', file_format, sep = '')     open_figure_for_saving(filename, file_format)     pairs(mcmc_outputs[, 3:ncol(mcmc_outputs)], main = 'Scatter plot', pch = 20)     dev.off() } master_plotting <- function(mcmc_outputs) {     # Runs all plotting functions     param_list = get_list_of_params(mcmc_outputs)     plot_parameter_progressions(mcmc_outputs, param_list, accepted_only = FALSE)     plot_log_likelihood_progression(mcmc_outputs)     plot_best_fit(mcmc_outputs, param_list)     plot_posterior_distributions(mcmc_outputs, param_list)     plot_param_collinearity(mcmc_outputs, param_list) }
M = master_mcmc_runner(100)
my_data
my_data$in_bed[i]
?dnrom
?dnorm
model_output
        single_log_lh = dnorm(x = my_data$in_bed[i], mean = model_output, sd = sd, log = TRUE)
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'MM' cycles <- 8
x <- mcmc_runner(n_accepted = 100, parameters)
output <- run_model(strategy = baseline_strategy, init= init, cycles = 8, inflow = TRUE)
output
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
mcmc_runner <- function(strategy, n_accepted = 100, parameters) {     init_params <- list()     for (each in names(parameters)) {         parameters[[each]]$env <- environment() # move evaluation of parameters to this environment         assign(each, lazy_eval(parameters[[each]])) # generate a pair lists for each parameter         init_params[[each]] <- eval(as.symbol(each)) # put the parameter value into a list     }     M = metropolis_hastings(strategy = strategy, log_lh_func = my_log_lh_func, log_priors_func = my_log_priors_func, proposal_func = my_proposal_func, init_params = init_params, n_accepted = n_accepted)     init_params }
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
mcmc_runner <- function(strategy, n_accepted = 100, parameters) {     init_params <- list()     for (each in names(parameters)) {         parameters[[each]]$env <- environment() # move evaluation of parameters to this environment         assign(each, lazy_eval(parameters[[each]])) # generate a pair lists for each parameter         init_params[[each]] <- eval(as.symbol(each)) # put the parameter value into a list     }     strategy     M = metropolis_hastings(strategy = strategy, log_lh_func = my_log_lh_func, log_priors_func = my_log_priors_func, proposal_func = my_proposal_func, init_params = init_params, n_accepted = n_accepted)     init_params }
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
mcmc_runner <- function(strategy, n_accepted = 100, parameters) {     init_params <- list()     for (each in names(parameters)) {         parameters[[each]]$env <- environment() # move evaluation of parameters to this environment         assign(each, lazy_eval(parameters[[each]])) # generate a pair lists for each parameter         init_params[[each]] <- eval(as.symbol(each)) # put the parameter value into a list     }     strategy     M = metropolis_hastings(strategy = strategy, log_lh_func = my_log_lh_func, log_priors_func = my_log_priors_func, proposal_func = my_proposal_func, init_params = init_params, n_accepted = n_accepted)     init_params }
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
mcmc_runner <- function(strategy, n_accepted = 100, parameters) {     init_params <- list()     for (each in names(parameters)) {         parameters[[each]]$env <- environment() # move evaluation of parameters to this environment         assign(each, lazy_eval(parameters[[each]])) # generate a pair lists for each parameter         init_params[[each]] <- eval(as.symbol(each)) # put the parameter value into a list     }     strategy     browser()     M = metropolis_hastings(strategy = strategy, log_lh_func = my_log_lh_func, log_priors_func = my_log_priors_func, proposal_func = my_proposal_func, init_params = init_params, n_accepted = n_accepted)     init_params }
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
metropolis_hastings(strategy = strategy, log_lh_func = my_log_lh_func, log_priors_func = my_log_priors_func, proposal_func = my_proposal_func, init_params = init_params, n_accepted = n_accepted)
metropolis_hastings <- function(strategy,                                 log_lh_func,                                 log_priors_func,                                 proposal_func,                                 init_params,                                 n_accepted,                                 max_iterations = 1e4) {     # log_lh_func: a function returning the log-likelihood value. This is log( P(data | theta) )     # priors_func: a function returning the joint prior log-likelihood of the parameters. This is  log( P(theta) )     # proposal_func (or jumping function): a function returning a new parameter set, starting from another parameter set. P(theta' | theta)     # init_params: a list containing the parameters. e.g list(beta=0.5, gamma=2.6)     # n_accepted: number of accepted runs     # max_iterations: maximum number of iterations allowed     # preliminary check: max_iterations has to be >= n_accepted     stopifnot(max_iterations >= n_accepted)     # prepare storage for the results. columns will be named "log_lh", "accepted", "param1", "param2", ...     results = data.frame(log_lh = double(), accepted = integer())     for (param_name in names(init_params)) {         results[[param_name]] = double()     }     # initialise counters     count_iterations <- 0     count_accepted <- 0     # calculate the likelihoods of the initial parameter set     current_params <- init_params # current_params is the last accepted set of paramaters      current_log_lh <- log_lh_func(strategy,init_params)     current_log_prior <- log_priors_func(init_params)     while (count_accepted < n_accepted) {         if (count_iterations >= max_iterations) {             print("The maximum number of iterations has been reached. The simulation has been aborted.")             break         }         # Generate a new candidate parameter set         proposed_params = proposal_func(current_params)         # Evaluate the likelihood of the new parameter set         proposed_log_lh = log_lh_func(proposed_params)         proposed_log_prior = log_priors_func(proposed_params)         # Acceptance or rejection?         accepted = 0         log_proba_of_acceptance = proposed_log_prior + proposed_log_lh - (current_log_prior + current_log_lh) # we could have stored (current_log_prior + current_log_lh) in a variable         proba_of_acceptance = exp(log_proba_of_acceptance) # transform to actual proba     } }
metropolis_hastings <- function(strategy,                                 log_lh_func,                                 log_priors_func,                                 proposal_func,                                 init_params,                                 n_accepted,                                 max_iterations = 1e4) {     # log_lh_func: a function returning the log-likelihood value. This is log( P(data | theta) )     # priors_func: a function returning the joint prior log-likelihood of the parameters. This is  log( P(theta) )     # proposal_func (or jumping function): a function returning a new parameter set, starting from another parameter set. P(theta' | theta)     # init_params: a list containing the parameters. e.g list(beta=0.5, gamma=2.6)     # n_accepted: number of accepted runs     # max_iterations: maximum number of iterations allowed     # preliminary check: max_iterations has to be >= n_accepted     stopifnot(max_iterations >= n_accepted)     # prepare storage for the results. columns will be named "log_lh", "accepted", "param1", "param2", ...     results = data.frame(log_lh = double(), accepted = integer())     for (param_name in names(init_params)) {         results[[param_name]] = double()     }     # initialise counters     count_iterations <- 0     count_accepted <- 0     # calculate the likelihoods of the initial parameter set     current_params <- init_params # current_params is the last accepted set of paramaters      current_log_lh <- log_lh_func(strategy,init_params)     current_log_prior <- log_priors_func(init_params)     while (count_accepted < n_accepted) {         if (count_iterations >= max_iterations) {             print("The maximum number of iterations has been reached. The simulation has been aborted.")             break         }         # Generate a new candidate parameter set         proposed_params = proposal_func(current_params)         # Evaluate the likelihood of the new parameter set         proposed_log_lh = log_lh_func(proposed_params)         proposed_log_prior = log_priors_func(proposed_params)         # Acceptance or rejection?         accepted = 0         log_proba_of_acceptance = proposed_log_prior + proposed_log_lh - (current_log_prior + current_log_lh) # we could have stored (current_log_prior + current_log_lh) in a variable         proba_of_acceptance = exp(log_proba_of_acceptance) # transform to actual proba     } }
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'MM' cycles <- 8
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
c
mcmc_runner <- function(strategy, n_accepted = 100, parameters) {     init_params <- list()     for (each in names(parameters)) {         parameters[[each]]$env <- environment() # move evaluation of parameters to this environment         assign(each, lazy_eval(parameters[[each]])) # generate a pair lists for each parameter         init_params[[each]] <- eval(as.symbol(each)) # put the parameter value into a list     }     M <- metropolis_hastings(strategy = strategy, log_lh_func = my_log_lh_func, log_priors_func = my_log_priors_func, proposal_func = my_proposal_func, init_params = init_params, n_accepted = n_accepted)     init_params }
output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
winter_h5$close_all()
winter_h5 <- H5File$new("Winter.h5", mode = "w")
my_log_lh_func <- function(strategy, params) {     # params is a list of parameters and associated values.     # return the likelihood value associated with the parameter set.     # this is p(D|theta)     browser()     # run winter model with the input parameters     winter_results <- run_model(strategy, params)     # Our likelihood is obtained by multiplying Gaussian elements centered on the model estimate for each datapoint.     # We assume that the standard deviation is 0.05. This means that 95% of the Gaussian density sits within an      # interval of width 0.1 (2*sd).     sd = 0.05     overall_log_lh = 0     for (i in 1:nrow(ind)) {         # for each date of the dataset         model_output = sir_results$I[sir_results$time == my_data$date[i]]         single_log_lh = dnorm(x = my_data$in_bed[i], mean = model_output, sd = sd, log = TRUE)         overall_log_lh = overall_log_lh + single_log_lh     }     return(overall_log_lh) }
mcmc_runner <- function(strategy, n_accepted = 100, parameters) {     init_params <- list()     for (each in names(parameters)) {         parameters[[each]]$env <- environment() # move evaluation of parameters to this environment         assign(each, lazy_eval(parameters[[each]])) # generate a pair lists for each parameter         init_params[[each]] <- eval(as.symbol(each)) # put the parameter value into a list     }     M <- metropolis_hastings(strategy = strategy, log_lh_func = my_log_lh_func, log_priors_func = my_log_priors_func, proposal_func = my_proposal_func, init_params = init_params, n_accepted = n_accepted)     init_params }
metropolis_hastings <- function(strategy,                                 log_lh_func,                                 log_priors_func,                                 proposal_func,                                 init_params,                                 n_accepted,                                 max_iterations = 1e4) {     # log_lh_func: a function returning the log-likelihood value. This is log( P(data | theta) )     # priors_func: a function returning the joint prior log-likelihood of the parameters. This is  log( P(theta) )     # proposal_func (or jumping function): a function returning a new parameter set, starting from another parameter set. P(theta' | theta)     # init_params: a list containing the parameters. e.g list(beta=0.5, gamma=2.6)     # n_accepted: number of accepted runs     # max_iterations: maximum number of iterations allowed     # preliminary check: max_iterations has to be >= n_accepted     stopifnot(max_iterations >= n_accepted)     # prepare storage for the results. columns will be named "log_lh", "accepted", "param1", "param2", ...     results = data.frame(log_lh = double(), accepted = integer())     for (param_name in names(init_params)) {         results[[param_name]] = double()     }     # initialise counters     count_iterations <- 0     count_accepted <- 0     # calculate the likelihoods of the initial parameter set     current_params <- init_params # current_params is the last accepted set of paramaters      current_log_lh <- log_lh_func(strategy,init_params)     current_log_prior <- log_priors_func(init_params)     while (count_accepted < n_accepted) {         if (count_iterations >= max_iterations) {             print("The maximum number of iterations has been reached. The simulation has been aborted.")             break         }         # Generate a new candidate parameter set         proposed_params = proposal_func(current_params)         # Evaluate the likelihood of the new parameter set         proposed_log_lh = log_lh_func(proposed_params)         proposed_log_prior = log_priors_func(proposed_params)         # Acceptance or rejection?         accepted = 0         log_proba_of_acceptance = proposed_log_prior + proposed_log_lh - (current_log_prior + current_log_lh) # we could have stored (current_log_prior + current_log_lh) in a variable         proba_of_acceptance = exp(log_proba_of_acceptance) # transform to actual proba     } }
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
run_model(strategy, params)
run_model(strategy, params, cycles = 8 )
    winter_results <- run_model(strategy, params, cycles = 8 )
Q
winter_h5$close_all()
winter_h5 <- H5File$new("Winter.h5", mode = "w")
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
    winter_results <- run_model(strategy, params, cycles = 8 )
winter_results
winter_results[[2]]
winter_results[[2]][,1,]
results_ds <- winter_results[[2]]
resutl[]
results_ds
results_ds[]
results_ds[1,,]
results_ds
results_ds['index']
results_ds[['index']]
results_ds[['index']][1,,]
results_ds[['index']][]
results_ds[['index']]
results_ds[['index']][1,1,1]
results_ds[['index']][1,1,1:10]
winter_results
winter_results <- winter_results[[1]][['output']]
winter_results[1, 1, 1:10]
winter_results[, 1, 1:10]
winter_results[, 1, ]
winter_results[1, 1, ]
winter_results[1, 1,1:10 ]
winter_results[, 1,1:10 ]
winter_results[, 1,1:10 ]
winter_results[, 1,1:1 ]
winter_results[1, 1,1:1 ]
winter_results[2, 1,1:1 ]
winter_results[, 1,1:1 ]
dim(winter_results)
dim(winter_results[, 1,])
dim(winter_results[1, 1,])
winter_results[, 1, ][,11:12]
winter_results[, 1, ][,11]
sum(winter_results[, 1, ][,11])
sum(winter_results[1, 1, ][,11])
sum(winter_results[2, 1, ][,11])
sum(winter_results[3, 1, ][,11])
sum(winter_results[4, 1, ][,11])
sum(winter_results[, 1, ][,11])
dim(winter_results[, 1,])
dim(winter_results[, 1,1:12])
dim(winter_results[, 1,])
dim(winter_results[, ,])
winter_results[, ,]
dim(winter_results[,2 ,])
winter_results[,2 ,]
winter_results[, 3,]
winter_results
winter_results[, 1,]
sum(winter_results[1, 1,][, 11])
sum(winter_results[1, 1,][, 11])
winter_results[, 1,]
    winter_results <- run_model(strategy, params, cycles = 8)
winter_h5$close_all()
winter_h5 <- H5File$new("Winter.h5", mode = "w")
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
    winter_results <- run_model(strategy, params, cycles = 8)
    winter_results <- winter_results[[1]][['output']]
winter_results[, 1,]
class(winter_results[, 1,])
sum(winter_results[1, 1,][, 11])
winter_results
winter_results[1, 1,][, 11:12]
winter_results[, 1,][, 11:12]
x <- winter_results[, 1,]
dim(x)
x
dim(x)
x
winter_results[1, 1,]
winter_results[1, 1, 4376]
x <- winter_results[1, 1, 1:4376]
x
    winter_results <- run_model(strategy, params, cycles = 8)
winter_h5$close_all()
winter_h5 <- H5File$new("Winter.h5", mode = "w")
    winter_results <- run_model(strategy, params, cycles = 8)
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'MM' cycles <- 8
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'MM' cycles <- 8
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
    winter_results <- run_model(strategy, params, cycles = 8)
    winter_results <- winter_results[[1]][['output']]
winter_results
winter_results[,1,]
winter_results[,1,]
winter_results[,1,10]
winter_results[,1,1]
winter_results[10,1,]
winter_results[9,1,]
dim(winter_results[,1,])
winter_results[,1,][,11,]
winter_results[, 1,][, 11:12]
winter_results[, 1,1][, 11:12]
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'MM' cycles <- 8
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'MM' cycles <- 8
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w")
# source files
source("parameters.R")
source("object creator.R")
source("run_model.R")
source("calculate_complement.R")
source("perform_matrix_multiplication.R")
source("get_state_counts.R")
source("initialise_hfd5.R")
source('load_data.R')
source('mcmc.R')
object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'MM' cycles <- 8 output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
winter_h5$close_all()
object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'MM' cycles <- 8
x <- mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
    winter_results <- run_model(strategy, params, cycles = 8)
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'MM' cycles <- 8
mcmc_runner(strategy = baseline_strategy,n_accepted = 100, parameters)
    winter_results <- run_model(strategy, params, cycles = 8)
winter_results
winter_results[[1]][['output']]
winter_results[,1,][,11,]
winter_results[,1,][,11,]
winter_results
winter_results[[1]][['output']]
    winter_results <- winter_results[[1]][['output']]
c
winter_h5$close_all()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'Mammogram' cycles <- 8 x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100, parameters)
    winter_results <- run_model(strategy, params, cycles = 8)
    winter_results <- winter_results[[1]][['output']]
winter_results
winter_results[,1,]
winter_results
winter_results[,1,][,11,]
winter_results[,1,]
winter_results
winter_results[1,1,]
winter_results
winter_results[,1,][1]
winter_results[,1,][21]
winter_results[,1,1:10]
winter_results[,1,1:10]
winter_results[,1,1:10]
winter_results[1,1,1:10]
winter_results[0,1,1:10]
winter_results[1,1,1]
winter_results[, 1,1][, 11:12]
sum(winter_results[, 1,][, 11:12])
winter_results[9,1,][,11,]
winter_results[9, 1,]
winter_results[9, 1,]
winter_results[9, 1,][1, 11:12]
sum(winter_results[9, 1,][, 11:12])
winter_results[,1,1]
plot(x = 1:9, y = winter_results[,1,1])
plot(x = 1:9, y = winter_results[,1,1][,11])
plot(x = 1:9, y = winter_results[,1,1][,11:12])
barplot(winter_results[,1,1][,11:12])
winter_results[,1,1][,11:12]
plot(winter_results[,1,1][,11:12])
Q
ind4_cancer
sum(ind4_cancer[,5])
ind1_participation
ind1_participation
sum(ind1_participation[,4])
apply(ind1_participation, 4, sum)
ind1_participation
apply(ind1_participation[,4], 4, sum)
apply(ind1_participation[,4], 2, sum)
apply(ind1_participation[,4], , sum)
apply(ind1_participation[,4], 1, sum)
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs)
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–20']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–30']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–85']     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL] }
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer_state <- fread(paste(data_path, 'Cancer_state_7.csv', sep = ""))
data_path <- "M:/Documents/@Projects/BCS/data/PBI Indicators/"
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer_state <- fread(paste(data_path, 'Cancer_state_7.csv', sep = ""))
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–20']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–30']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–85']     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL] }
ind7_cancer <- clean_up_indicator_7(ind7_cancer)
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer_state <- fread(paste(data_path, 'Cancer_state_7.csv', sep = ""))
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–20']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–30']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–100'] # all 85+ year old women considered 85-100     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL] }
ind7_cancer <- clean_up_indicator_7(ind7_cancer)
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer <- clean_up_indicator_7(ind7_cancer)
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–20']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–30']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–100'] # all 85+ year old women considered 85-100     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)] }
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer <- clean_up_indicator_7(ind7_cancer)
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–19']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–30']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–100'] # all 85+ year old women considered 85-100     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)] }
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer <- clean_up_indicator_7(ind7_cancer)
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–19']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–30']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–100'] # all 85+ year old women considered 85-100     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)] }
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer <- clean_up_indicator_7(ind7_cancer)
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–19']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–30']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–100'] # all 85+ year old women considered 85-100     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)] }
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer <- clean_up_indicator_7(ind7_cancer)
rm(clean_up_indicator_7, envir = as.environment(".GlobalEnv"))
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–19']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–30']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–100'] # all 85+ year old women considered 85-100     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)] }
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer <- clean_up_indicator_7(ind7_cancer)
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–19']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–29']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–99'] # all 85+ year old women considered 85-99     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)]     browser()     DT <- DT[, list(age = seq(from = l_age, to = u_age)), by = .(seq_len(nrow(DT)), NUM_WOMEN, Period, Screen, STATE, calculated_mean)]     DT[, seq_len := NULL]     DT }
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer <- clean_up_indicator_7(ind7_cancer)
DT
DT[, list(age = seq(from = l_age, to = u_age)), by = .(seq_len(nrow(DT)), NUM_WOMEN, Period )]
DT[, list(age = seq(from = l_age, to = u_age)), by = .(seq_len(nrow(DT)), NUM_WOMEN, Period, calculated_mean)]
DT[, list(age = seq(from = l_age, to = u_age)), by = .(NUM_WOMEN, Period, calculated_mean)]
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–19']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–29']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–99'] # all 85+ year old women considered 85-99     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)]     DT <- DT[, list(age = seq(from = l_age, to = u_age)), by = .(seq_len(nrow(DT)), NUM_WOMEN, Period, calculated_mean)]     DT[, seq_len := NULL]     DT }
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–19']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–29']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–99'] # all 85+ year old women considered 85-99     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)]     DT <- DT[, list(age = seq(from = l_age, to = u_age)), by = .(seq_len(nrow(DT)), NUM_WOMEN, Period, calculated_mean)]     DT[, seq_len := NULL]     DT }
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer <- clean_up_indicator_7(ind7_cancer)
ind7_cancer_state <- fread(paste(data_path, 'Cancer_state_7.csv', sep = ""))
ind7_cancer_state <- clean_up_indicator_7(ind7_cancer_state)
ind7_cancer_state <- fread(paste(data_path, 'Cancer_state_7.csv', sep = ""))
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer_state <- fread(paste(data_path, 'Cancer_state_7.csv', sep = ""))
names(ind7_cancer_state)
names(ind7_cancer_state)['Num_women'] <- 'NUM_WOMEN'
names(ind7_cancer_state)['Num_women']
names(ind7_cancer_state)[5]
names(ind7_cancer_state)[5] <- 'NUM_WOMEN'
names(ind7_cancer_state)[3] <- 'STATE'
fwrite(ind7_cancer_state, paste(data_path,'Cancer_state_7.csv', sep =""))
rm(ind7_cancer, envir = as.environment(".GlobalEnv"))
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = "")) ind7_cancer_state <- fread(paste(data_path, 'Cancer_state_7.csv', sep = ""))
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–19']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–29']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–99'] # all 85+ year old women considered 85-99     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)]     DT <- DT[, list(age = seq(from = l_age, to = u_age)), by = .(seq_len(nrow(DT)), NUM_WOMEN, Period, calculated_mean)]     DT[, seq_len := NULL]     DT }
ind7_cancer_state <- clean_up_indicator_7(ind7_cancer_state)
ind7_cancer_state <- fread(paste(data_path, 'Cancer_state_7.csv', sep = ""))
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     DT[, Period := gsub('â€“', '–', Period)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–19']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–29']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–99'] # all 85+ year old women considered 85-99     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)]     DT <- DT[, list(age = seq(from = l_age, to = u_age)), by = .(seq_len(nrow(DT)), NUM_WOMEN, Period, calculated_mean)]     DT[, seq_len := NULL]     DT }
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer_state <- fread(paste(data_path, 'Cancer_state_7.csv', sep = ""))
ind7_cancer <- clean_up_indicator_7(ind7_cancer)
ind7_cancer_state <- clean_up_indicator_7(ind7_cancer_state)
ind7_cancer_state <- fread(paste(data_path, 'Cancer_state_7.csv', sep = ""))
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     browser()     DT[, Period := gsub('â€“', '–', Period)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–19']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–29']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–99'] # all 85+ year old women considered 85-99     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)]     DT <- DT[, list(age = seq(from = l_age, to = u_age)), by = .(seq_len(nrow(DT)), NUM_WOMEN, Period, calculated_mean)]     DT[, seq_len := NULL]     DT }
ind7_cancer_state <- fread(paste(data_path, 'Cancer_state_7.csv', sep = ""))
ind7_cancer_state <- clean_up_indicator_7(ind7_cancer_state)
    DT[, Period := gsub('â€“', '–', Period)]
    DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–19']
    DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–29']
    DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']
    DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–99'] # all 85+ year old women considered 85-99
    if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }
c
    DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]
DT
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
Q
clean_up_indicator_7 <- function(DT) {     # <20 year olds considered 0 - 20     DT[, `AGE GROUP (YEARS)` := gsub('â€“', '–', `AGE GROUP (YEARS)`)]     browser()     DT[, Period := gsub('â€“', '–', Period)]     DT[`AGE GROUP (YEARS)` == '<20', `AGE GROUP (YEARS)` := '0–19']     DT[`AGE GROUP (YEARS)` == '<30', `AGE GROUP (YEARS)` := '0–29']     DT[`AGE GROUP (YEARS)` == '30-39', `AGE GROUP (YEARS)` := '30–39']     DT[`AGE GROUP (YEARS)` == '85+', `AGE GROUP (YEARS)` := '85–99'] # all 85+ year old women considered 85-99     if (any(DT$Period %like% '–')) {         DT[, c('l_period', 'u_period') := tstrsplit(Period, '–', fixed = TRUE, type.convert = TRUE)]         DT[, c('Period') := NULL]     }     DT[, c('l_age', 'u_age') := tstrsplit(`AGE GROUP (YEARS)`, '–', fixed = TRUE, type.convert = TRUE)]     DT[, c('AGE GROUP (YEARS)') := NULL]     DT[, c('calculated_mean') := NUM_WOMEN / (u_age - l_age + 1)]     DT <- DT[, list(age = seq(from = l_age, to = u_age)), by = .(seq_len(nrow(DT)), NUM_WOMEN, Period, calculated_mean)]     DT[, seq_len := NULL]     DT }
ind7_cancer <- fread(paste(data_path, 'Cancer_7.csv', sep = ""))
ind7_cancer <- clean_up_indicator_7(ind7_cancer)
c
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'Mammogram' cycles <- 8
Q
winter_h5$close_all()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'Mammogram' cycles <- 8
winter_h5$close_all()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'Mammogram' cycles <- 8
winter_h5$close_all()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'Mammogram' cycles <- 8
source('load_data.R')
traceback()
source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 init <- winter_input_dt[l_period == start_year] test <- 'Mammogram' cycles <- 8
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100, parameters)
    winter_results <- run_model(strategy, params, cycles = 8)
    winter_results <- winter_results[[1]][['output']]
winter_h5$close_all()
Q
winter_h5 <- H5File$new("Winter.h5", mode = "w")
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100, parameters)
    winter_results <- run_model(strategy, params, cycles = 8)
Q
baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     )
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean]
baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     )
init <- winter_input_dt[l_period == start_year]
test <- 'Mammogram'
cycles <- 8
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100, parameters)
strategy$properties$cycles
eval(strategy$properties$cycles)
lazyeval(strategy$properties$cycles)
lazy_eval(strategy$properties$cycles)
    winter_results <- run_model(strategy, params, cycles = lazy_eval(strategy$properties$cycles))
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     )
baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     )
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     )
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     )
init <- winter_input_dt[l_period == start_year]
start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == start_year] test <- 'Mammogram'
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100, parameters)
class(baseline_strategy)
strategy
strategy$parameters
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy)
names(strategy$parameters)
mcmc_runner <- function(strategy, n_accepted = 100) {     init_params <- list()     for (each in names(strategy$parameters)) {         strategy$parameters[[each]]$env <- environment() # move evaluation of parameters to this environment         assign(each, lazy_eval(strategy$parameters[[each]])) # generate a pair lists for each parameter         init_params[[each]] <- eval(as.symbol(each)) # put the parameter value into a list     }     M <- metropolis_hastings(strategy = strategy, log_lh_func = my_log_lh_func, log_priors_func = my_log_priors_func, proposal_func = my_proposal_func, init_params = init_params, n_accepted = n_accepted) }
baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     )
init <- winter_input_dt[l_period == start_year]
init <- winter_input_dt[l_period == baseline_strategy$start_year]
output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
traceback()
# Attempt at method dispatch run_model <- function(strategy, ...) {     UseMethod('run_model',strategy) } # The main model runtime loop  run_model.default <- function(...,                      parameters = NULL,                      init = NULL,                      cycles = NULL,                      scenario_env = NULL,                      method = NULL,                      cost = NULL,                      effect = NULL,                      inflow = TRUE,                      dsa = FALSE) {     uneval_strategy_list <- list(...)     strategy <- uneval_strategy_list[[1]] # assuming there is only one strategy!     eval_strategy <- strategy     year <- start_year # Initialise year with start_year     markov_cycle <- 0 # Tracks the current cycle     # A conditional flag used for inflows.     my_name <- lazy_eval(strategy$properties$my_name)     # fills index_ds and output_ds with initial values     group <- initialise_hfd5(strategy = strategy)     # Create names for datasets     # TODO - move index_ds to strategy level group and pre-calculate it.     # then all variations(scenarios) of the strategy can reference it.     index_ds <- group[[2]][["index"]]     output_ds <- group[[1]][['output']]     while (markov_cycle < cycles) {         #current_rows <- which(index_ds[]$cycle == markov_cycle)         current_rows <- nrow(index_ds[markov_cycle+1,1,])         writeLines(sprintf("\nCommencing Markov cycle %i", markov_cycle))         writeLines(sprintf("Current number of populations in the working matrix is %i", current_rows))         print(setDT(index_ds[markov_cycle+1,1,])[1:10, .N, by = .(age)])         results <- get_state_counts(index_ds, output_ds, year, strategy, markov_cycle,dsa)         # Update counters         markov_cycle <- markov_cycle + 1         year <- year + 1         # Aging the population in the calculation object         index_ds[markov_cycle+1, 1,] <- index_ds[markov_cycle,1,]         index_ds[markov_cycle+1, 1,][, 'age'] <- index_ds[markov_cycle, 1,][, 'age'] + 1         size <- nrow(index_ds[markov_cycle + 1,1,])         # Inflows for next cycle.          if ((my_name == "S1" || my_name == "S0_1"             || my_name == "S2" || my_name == "S0_12") && markov_cycle > 5) {             inflow <- FALSE         }         if (inflow) {             # TODO -  Need a check to ensure pop_inflow has data             pop_inflow <- winter_input_dt[l_period == year,]         }         else {             pop_inflow <- NULL # not convinced this is needed         }         if (inflow) {             # index test             start <- nrow(index_ds[markov_cycle+1,1,]) + 1             end <- start + nrow(pop_inflow) - 1             x <- pop_inflow[, !..state_names]             index_ds[markov_cycle + 1, 1, start:end] <- x             # update state count in output_ds with new arrivals             output_ds[markov_cycle + 1, 1, start:end] <- pop_inflow[, ..state_names]         }     } } # The main model runtime loop  run_model.dsa <- function(...,                      parameters = NULL,                      init = NULL,                      cycles = NULL,                      scenario_env = NULL,                      method = NULL,                      cost = NULL,                      effect = NULL,                      inflow = TRUE,                      dsa = TRUE) {     uneval_strategy_list <- list(...)     strategy <- uneval_strategy_list[[1]]     eval_strategy <- strategy     # The names test and treatment are specific to the model     # TODO -  Find a generic method to extract the name value     strategy_p1 <- lazy_eval(eval_strategy$properties$test)     strategy_p2 <- lazy_eval(eval_strategy$properties$treatment)     # A conditional flag used for inflows.     my_name <- lazy_eval(strategy$properties$my_name)     # dsa loop     dsa_run <- 1:nrow(strategy$dsa$dsa)     do_dsa <- function(a_run) {         year <- start_year # Initialise year with start_year         markov_cycle <- 0 # Tracks the current cycle         # fills index_ds and output_ds with initial values         group <- initialise_hfd5(strategy_p1, strategy_p2, my_name, a_run, strategy = strategy)         # Create names for datasets         # TODO - move index_ds to strategy level group and pre-calculate it.         # then all variations(scenarios) of the strategy can reference it.         index_ds <- group[[2]][["index"]]         output_ds <- group[[1]][[paste('dsa',a_run, sep = '_')]]         while (markov_cycle < cycles) {             #current_rows <- which(index_ds[]$cycle == markov_cycle)             current_rows <- nrow(index_ds[markov_cycle + 1, 1,])             writeLines(sprintf("\nCommencing Markov cycle %i", markov_cycle))             writeLines(sprintf("Current number of populations in the working matrix is %i", current_rows))             print(setDT(index_ds[markov_cycle + 1, 1,])[1:10, .N, by = .(AGEP)])             results <- get_state_counts(index_ds, output_ds, year, strategy, markov_cycle, dsa, a_run)             # Update counters             markov_cycle <- markov_cycle + 1             year <- year + 1             # Aging the population in the calculation object             index_ds[markov_cycle + 1, 1,] <- index_ds[markov_cycle, 1,]             index_ds[markov_cycle + 1, 1,][, 1] <- index_ds[markov_cycle, 1,][, 1] + 1             size <- nrow(index_ds[markov_cycle + 1, 1,])             # Inflows for next cycle.              if ((my_name == "S1" || my_name == "S0_1"                 || my_name == "S2" || my_name == "S0_12") && markov_cycle > 5) {                 inflow <- FALSE             }             if (inflow) {                 pop_inflow <- winter_input_dt[YARP == year,][, cycle := NA]             }             else {                 pop_inflow <- NULL # not convinced this is needed             }             if (inflow) {                 # index test                 start <- nrow(index_ds[markov_cycle + 1, 1,]) + 1                 end <- start + nrow(pop_inflow) - 1                 x <- pop_inflow[, !..state_names][, 1:7]                 index_ds[markov_cycle + 1, 1, start:end] <- x                 # update state count in output_ds with new arrivals                 output_ds[markov_cycle + 1, 1, start:end] <- pop_inflow[, ..state_names]             }         }     }     lapply(dsa_run, do_dsa) } run_model.mcmc <- function(...,                      parameters = NULL,                      init = NULL,                      cycles = NULL,                      scenario_env = NULL,                      method = NULL,                      cost = NULL,                      effect = NULL,                      inflow = TRUE,                      dsa = FALSE,                      mcmc = TRUE) {     uneval_strategy_list <- list(...)     strategy <- uneval_strategy_list[[1]]     eval_strategy <- strategy     year <- strategy$start_year # Initialise year with start_year     markov_cycle <- 0 # Tracks the current cycle     # A conditional flag used for inflows.     my_name <- lazy_eval(strategy$properties$my_name)     # fills index_ds and output_ds with initial values     group <- initialise_hfd5(strategy = strategy)     # Create names for datasets     # TODO - move index_ds to strategy level group and pre-calculate it.     # then all variations(scenarios) of the strategy can reference it.     index_ds <- group[[2]][["index"]]     output_ds <- group[[1]][['output']]     while (markov_cycle < cycles) {         #current_rows <- which(index_ds[]$cycle == markov_cycle)         current_rows <- nrow(index_ds[markov_cycle + 1, 1,])         writeLines(sprintf("\nCommencing Markov cycle %i", markov_cycle))         writeLines(sprintf("Current number of populations in the working matrix is %i", current_rows))         print(setDT(index_ds[markov_cycle + 1, 1,])[1:10, .N, by = .(age)])         results <- get_state_counts(index_ds, output_ds, year, strategy, markov_cycle, dsa)         # Update counters         markov_cycle <- markov_cycle + 1         year <- year + 1         # Aging the population in the calculation object         index_ds[markov_cycle + 1, 1,] <- index_ds[markov_cycle, 1,]         index_ds[markov_cycle + 1, 1,][, 'age'] <- index_ds[markov_cycle, 1,][, 'age'] + 1         size <- nrow(index_ds[markov_cycle + 1, 1,])         # Inflows for next cycle.          if ((my_name == "S1" || my_name == "S0_1"             || my_name == "S2" || my_name == "S0_12") && markov_cycle > 5) {             inflow <- FALSE         }         if (inflow) {             # TODO -  Need a check to ensure pop_inflow has data             pop_inflow <- winter_input_dt[l_period == year,]         }         else {             pop_inflow <- NULL # not convinced this is needed         }         if (inflow) {             # index test             start <- nrow(index_ds[markov_cycle + 1, 1,]) + 1             end <- start + nrow(pop_inflow) - 1             x <- pop_inflow[, !..state_names]             index_ds[markov_cycle + 1, 1, start:end] <- x             # update state count in output_ds with new arrivals             output_ds[markov_cycle + 1, 1, start:end] <- pop_inflow[, ..state_names]         }     }     group }
mcmc_runner(strategy = baseline_strategy, n_accepted = 100, parameters)
output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
test <- 'Mammogram'
output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
traceback(0)
output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
traceback()
initialise_hfd5 <- function(..., strategy) {     UseMethod('initialise_hfd5', strategy) } # Initialise HDF5 initialise_hfd5.default <- function(strategy) {     cycles <- strategy$cycles     # Create the scenario groups in HFD5     group_name <- lazy_eval(strategy$properties$my_name)     for (each in strategy$properties[names(strategy$properties) != 'my_name']) {         group_name <- paste(group_name, lazy_eval(each), sep = '/')     }     # Create a group link to the index dataset     if (!(strategy$properties$my_name$expr %in% names(winter_h5))) {         index_grp <- winter_h5$create_group(paste(strategy$properties$my_name$expr))     } else {         index_grp <- winter_h5[[strategy$properties$my_name$expr]]     }     # Check to see if the dataset exist or not. Then make appropriate link     if (!(group_name %in% list.groups(winter_h5))) {         scenario_grp <- winter_h5$create_group(group_name)     } else {         scenario_grp <- winter_h5[[group_name]]     }     # Creating a 3D array for the index data set     # TODO - change all hard coded values to refer winter_input_dt for attributes     index_column_names <- names(winter_input_dt[, -(..state_names)])     get_type <- function(col_name) {         typeof(winter_input_dt[[col_name]])     }     list_of_types <- lapply(index_column_names, get_type)     # Creating the index datatypes     # TODO - figure out how to create compound datatype using list_of_types     compound_index <- H5T_COMPOUND$new(index_column_names,                                    dtypes = list(h5types$H5T_NATIVE_INT, H5T_STRING$new(size = 3), h5types$H5T_NATIVE_INT,                                    h5types$H5T_IEEE_F32LE, h5types$H5T_NATIVE_INT))     index_space <- H5S$new(dim = c(cycles + 1, 1, nrow(init)), maxdims = c(cycles + 1, 1, Inf))     # Above should be implemented like this.     compound_output <- H5T_COMPOUND$new(names(strategy$states),                                    dtypes = rep(list(eval(Quote(h5types$H5T_IEEE_F32LE))), strategy$state_number))     #index_space <- H5S$new(dim = c(cycles + 1, 1, nrow(init)), maxdims = c(cycles + 1, 1, Inf))     output_space <- H5S$new(dim = c(cycles + 1, 5, nrow(init)), maxdims = c(cycles + 1, 5, Inf))     if ('index' %in% names(winter_h5[[strategy$properties$my_name$expr]])) {         index_grp$link_delete('index')         index_grp$create_dataset(name = 'index', space = index_space,                                                         dtype = compound_index)     } else {         index_grp$create_dataset(name = 'index', space = index_space,                                                         dtype = compound_index)     }     if (!('output' %in% list.datasets(scenario_grp))) {         scenario_grp$create_dataset(name = 'output', space = output_space, dtype = compound_output)     }     index_ds <- index_grp[['index']]     x <- copy(init[, ..index_column_names])     index_ds[1,1, ] <- x     output_ds <- scenario_grp[['output']]     output_ds[1, 1,] <- init[, ..state_names]     list(scenario_grp,index_grp) } # Initialise HDF5 initialise_hfd5.dsa <- function(strategy.grp, strategy_p1, strategy_p2, my_name, a_run, strategy) {     cycles <- strategy$cycles     dsa <- paste('dsa', a_run, sep = '_')     group_name <- paste(strategy$properties$my_name$expr, paste(strategy_p1, strategy_p2, sep = "_"), sep = '/')     # Create the scenario groups in HFD5     if (!(strategy$properties$my_name$expr %in% names(winter_h5))) {         index_grp <- winter_h5$create_group(paste(strategy$properties$my_name$expr))     } else {         index_grp <- winter_h5[[strategy$properties$my_name$expr]]     }     if (a_run == '1') {         scenario_grp <- winter_h5$create_group(group_name)     } else {         scenario_grp <- winter_h5[[group_name]]     }     # Creating a 3D array for the index data set     # TODO - change all hard coded values to refer winter_input_dt for attributes     compound_index <- H5T_COMPOUND$new(c('AGEP', 'ISO3', 'YARP', 'NUMP', 'LTBP', 'AGERP', 'SEXP'),                                    dtypes = list(h5types$H5T_NATIVE_INT, H5T_STRING$new(size = 3), h5types$H5T_NATIVE_INT,                                    h5types$H5T_IEEE_F32LE, h5types$H5T_IEEE_F32LE, h5types$H5T_NATIVE_INT, H5T_STRING$new(size = 3)))     index_space <- H5S$new(dim = c(cycles + 1, 1, nrow(init)), maxdims = c(cycles + 1, 1, Inf))     # Above should be implemented like this.     compound_output <- H5T_COMPOUND$new(names(strategy$states),                                    dtypes = rep(list(eval(Quote(h5types$H5T_IEEE_F32LE))), strategy$state_number))     #index_space <- H5S$new(dim = c(cycles + 1, 1, nrow(init)), maxdims = c(cycles + 1, 1, Inf))     output_space <- H5S$new(dim = c(cycles + 1, 5, nrow(init)), maxdims = c(cycles + 1, 5, Inf))     if ('index' %in% names(winter_h5[[strategy$properties$my_name$expr]])) {         index_grp$link_delete('index')         index_grp$create_dataset(name = 'index', space = index_space,                                                         dtype = compound_index)     } else {         index_grp$create_dataset(name = 'index', space = index_space,                                                         dtype = compound_index)     }     scenario_grp$create_dataset(name = dsa, space = output_space, dtype = compound_output)     index_ds <- index_grp[['index']]     x <- copy(init[, .(AGEP, ISO3, YARP, NUMP, LTBP, AGERP, SEXP)])     index_ds[1, 1,] <- x     output_ds <- scenario_grp[[dsa]]     output_ds[1, 1,] <- init[, ..state_names]     list(scenario_grp, index_grp) }
output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
params
params
    winter_results <- run_model(strategy, params, cycles = lazy_eval(strategy$properties$cycles))
Q
winter_h5$close_all()
winter_h5 <- H5File$new("Winter.h5", mode = "w")
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
c
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
c
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
    winter_results <- run_model(strategy, params, cycles = lazy_eval(strategy$properties$cycles))
strategy$properties$cycles
strategy$cycles
run_model(strategy, params, cycles = strategy$cycles)
    winter_results <- run_model(strategy, params, cycles = strategy$cycles)
Q
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
    winter_results <- run_model(strategy, params, cycles = strategy$cycles)
winter_h5$close_all()
winter_h5 <- H5File$new("Winter.h5", mode = "a")
    winter_results <- run_model(strategy, params, cycles = strategy$cycles)
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t', 'sev.b', 'sev.r', 'sev.t',                  'scr.detected', 'detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_BC <- NULL cur_RC <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_participation[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram'
winter_h5$close_all()
winter_h5 <- H5File$new("Winter.h5", mode = "w")
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
    winter_results <- run_model(strategy, params, cycles = strategy$cycles)
    winter_results <- winter_results[[1]][['output']]
winter_results[1, 1, 1]
winter_results[9, 1,][, 11,]
winter_results[9, 1,][, 11:12]
ind7_cancer
winter_results[9, 1,]
ind7_cancer
winter_results[,1,]
winter_results
winter_h5$close_all()
state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected')
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs)
H5File$new
?H5File$new
winter_h5 <- H5File$new("Winter.h5", mode = "w")
# source files
source("parameters.R")
source("object creator.R")
source("run_model.R")
source("calculate_complement.R")
source("perform_matrix_multiplication.R")
source("get_state_counts.R")
source("initialise_hfd5.R")
source('load_data.R')
source('mcmc.R')
object_creator <- create_objects(state_names)
#Create a list of values for the transition matrix
baseline_arglist <- object_creator$create_argument_list()
baseline_arglist$edit_list()
baseline_arglist$save_list('test1')
baseline_arglist$load_list('test1')
baseline_arglist$edit_list()
baseline_arglist$load_list('baseline_tmatrix')
baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values())
state_list <- object_creator$create_states(state_names, a=x, b=y, c=z)
baseline_arglist$update_list()
baseline_arglist$edit_list()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,12) state_cost <- rep(10, 12) utility <- rep(1, 12) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               BC = get_BC(cur_BC),                                               RC = get_RC(cur_RC,BC),                                               TC = (1 - BC - RC),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               POS = get_POS(cur_POS),                                               PPC = get_PPC(cur_PPC)                                               ) # POS - probability of screening # PPC - probability of presenting clinically # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     )
class(baseline_strategy)
init <- winter_input_dt[l_period == baseline_strategy$start_year]
output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
test <- 'Mammogram'
start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram'
output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
traceback(0)
output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
traceback()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram'
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram' x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
library(deSolve) # You first need to install this package if not already done
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram' x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100) output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE) winter_input_dt[l_period == 2008] do_scenario <- function (list_of_tests, list_of_treatments) {     do_test <- function(test) {         do_treatment <- function(treatment) {             # copies the scenario environment in order to evaluate test & treatment             s2_strategy$properties$test$env <- environment()             s2_strategy$properties$treatment$env <- environment()             run_model(strategy = baseline_strategy, init = init, cycles = cycles)         }         lapply(list_of_treatments, do_treatment)     }     lapply(list_of_tests, do_test) } baseline_arglist <- object_creator$create_argument_list(list_values) baseline_arglist$load_list("baseline") baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) baseline_state_list <- object_creator$create_states(state_names) baseline_strategy <- object_creator$define_strategy(test = "",                                                     treatment = "",                                                     my_name = "BASELINE",                                                     states = baseline_state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = dsa)
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram' x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100) output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE) winter_input_dt[l_period == 2008] do_scenario <- function (list_of_tests, list_of_treatments) {     do_test <- function(test) {         do_treatment <- function(treatment) {             # copies the scenario environment in order to evaluate test & treatment             s2_strategy$properties$test$env <- environment()             s2_strategy$properties$treatment$env <- environment()             run_model(strategy = baseline_strategy, init = init, cycles = cycles)         }         lapply(list_of_treatments, do_treatment)     }     lapply(list_of_tests, do_test) } baseline_arglist <- object_creator$create_argument_list(list_values) baseline_arglist$load_list("baseline") baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) baseline_state_list <- object_creator$create_states(state_names) baseline_strategy <- object_creator$define_strategy(test = "",                                                     treatment = "",                                                     my_name = "BASELINE",                                                     states = baseline_state_list,                                                     transition_matrix = baseline_matrix,                                                     dsa = dsa)
library(lazyeval) # required
library(data.table) # required
library(hdf5r)
library(lhs)
state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected')
# create a HDF5
winter_h5 <- H5File$new("Winter.h5", mode = "w")
winter_h5 <- H5File$new("Winter.h5", mode = "w")
getcwd()
getwd()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected')
winter_h5 <- H5File$new("Winter.h5", mode = "w")
# source files
source("parameters.R")
source("object creator.R")
source("run_model.R")
source("calculate_complement.R")
source("perform_matrix_multiplication.R")
source("get_state_counts.R")
source("initialise_hfd5.R")
source('load_data.R')
source('mcmc.R')
object_creator <- create_objects(state_names)
#Create a list of values for the transition matrix
baseline_arglist <- object_creator$create_argument_list()
baseline_arglist$load_list('baseline_tmatrix')
# baseline_arglist$edit_list()
#Create the transition matrix
baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values())
# Create a list of model states
state_list <- object_creator$create_states(state_names, a=x, b=y, c=z)
# Initialise 
cur_I <- NULL
cur_CB <- NULL
cur_CR <- NULL
cur_EB <- NULL
cur_ER <- NULL
cur_ET <- NULL
cur_KB <- NULL
cur_KR <- NULL
cur_KT <- NULL
cur_SN <- NULL
cur_SP <- NULL
cur_POS <- NULL
cur_PPC = NULL
flow_cost <- rep(1,9)
state_cost <- rep(10, 9)
utility <- rep(1, 9)
# Creates an unevaluated set of parameters
parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               )
# Create and initialise inputs
winter_input_dt <- ind1_population[, (state_names) := 0]
winter_input_dt[ , NoBC := calculated_mean]
# TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't
# matter, e.g. s2_strategey$properties$...
baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     )
# TODO - define_initialisation is extremely bespoke. More thought must be given to make it
# a generic method
class(baseline_strategy)
start_year <- 2008
cycles <- 8
init <- winter_input_dt[l_period == baseline_strategy$start_year]
test <- 'Mammogram'
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
winter_input_dt[l_period == 2008]
do_scenario <- function (list_of_tests, list_of_treatments) {     do_test <- function(test) {         do_treatment <- function(treatment) {             # copies the scenario environment in order to evaluate test & treatment             s2_strategy$properties$test$env <- environment()             s2_strategy$properties$treatment$env <- environment()             run_model(strategy = baseline_strategy, init = init, cycles = cycles)         }         lapply(list_of_treatments, do_treatment)     }     lapply(list_of_tests, do_test) }
baseline_arglist <- object_creator$create_argument_list(list_values)
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram' x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100) output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
winter_h5$close_all()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram' x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100) output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram' x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100) output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
winter_h5$close_all()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram' x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100) output <- run_model(strategy = baseline_strategy, init = init, cycles = 8, inflow = TRUE)
winter_h5$close_all()
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
c
winter_h5$close_all()
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
    winter_results <- run_model(strategy, params, cycles = strategy$cycles)
winter_results
    winter_results <- run_model(strategy, params, cycles = strategy$cycles)
strategy
run_model.mcmc <- function(...,                      parameters = NULL,                      init = NULL,                      cycles = NULL,                      scenario_env = NULL,                      method = NULL,                      cost = NULL,                      effect = NULL,                      inflow = TRUE,                      dsa = FALSE,                      mcmc = TRUE) {     uneval_strategy_list <- list(...)     strategy <- uneval_strategy_list[[1]]     eval_strategy <- strategy     year <- strategy$start_year # Initialise year with start_year     markov_cycle <- 0 # Tracks the current cycle     browser()     # A conditional flag used for inflows.     my_name <- lazy_eval(strategy$properties$my_name)     # fills index_ds and output_ds with initial values     group <- initialise_hfd5(strategy = strategy)     # Create names for datasets     # TODO - move index_ds to strategy level group and pre-calculate it.     # then all variations(scenarios) of the strategy can reference it.     index_ds <- group[[2]][["index"]]     output_ds <- group[[1]][['output']]     while (markov_cycle < cycles) {         #current_rows <- which(index_ds[]$cycle == markov_cycle)         current_rows <- nrow(index_ds[markov_cycle + 1, 1,])         writeLines(sprintf("\nCommencing Markov cycle %i", markov_cycle))         writeLines(sprintf("Current number of populations in the working matrix is %i", current_rows))         print(setDT(index_ds[markov_cycle + 1, 1,])[1:10, .N, by = .(age)])         results <- get_state_counts(index_ds, output_ds, year, strategy, markov_cycle, dsa)         # Update counters         markov_cycle <- markov_cycle + 1         year <- year + 1         # Aging the population in the calculation object         index_ds[markov_cycle + 1, 1,] <- index_ds[markov_cycle, 1,]         index_ds[markov_cycle + 1, 1,][, 'age'] <- index_ds[markov_cycle, 1,][, 'age'] + 1         size <- nrow(index_ds[markov_cycle + 1, 1,])         # Inflows for next cycle.          if ((my_name == "S1" || my_name == "S0_1"             || my_name == "S2" || my_name == "S0_12") && markov_cycle > 5) {             inflow <- FALSE         }         if (inflow) {             # TODO -  Need a check to ensure pop_inflow has data             pop_inflow <- winter_input_dt[l_period == year,]         }         else {             pop_inflow <- NULL # not convinced this is needed         }         if (inflow) {             # index test             start <- nrow(index_ds[markov_cycle + 1, 1,]) + 1             end <- start + nrow(pop_inflow) - 1             x <- pop_inflow[, !..state_names]             index_ds[markov_cycle + 1, 1, start:end] <- x             # update state count in output_ds with new arrivals             output_ds[markov_cycle + 1, 1, start:end] <- pop_inflow[, ..state_names]         }     }     group }
c
    winter_results <- run_model(strategy, params, cycles = strategy$cycles)
winter_h5$close_all()
winter_h5$close_all()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8
init <- winter_input_dt[l_period == baseline_strategy$start_year]
test <- 'Mammogram'
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
run_model(strategy, params, cycles = strategy$cycles)
    winter_results <- run_model(strategy, params, cycles = strategy$cycles)
Q
winter_h5$close_all()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create a list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram' x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
    winter_output <- winter_results[[1]][['output']]
    winter_index <- winter_results[[2]][['index']]
    overall_log_lh = 0
    for (i in 1:nrow(ind7_cancer)) {         # for each date of the dataset         winter_calibration_data <- find_calibration_data(winter_index, winter_output)         #model_output = sir_results$I[sir_results$time == my_data$date[i]]         #single_log_lh = dnorm(x = my_data$in_bed[i], mean = model_output, sd = sd, log = TRUE)         winter_output[4, 1,1:10]         winter_index[1,1,1:10]         overall_log_lh = overall_log_lh + single_log_lh     }
c
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create an empty list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # load an existing transition matrix # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram'
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
winter_results
    winter_results <- run_model(strategy, params, cycles = strategy$cycles)
    winter_output <- winter_results[[1]][['output']]
    winter_index <- winter_results[[2]][['index']]
winter_index
        winter_index[1,1,1:10]
        winter_output[4, 1,1:10]
        winter_output[4, 1,1:10]
        winter_output[1, 1,1:10]
        winter_output[2, 1,1:10]
        winter_output[3, 1,1:10]
        winter_output[7, 1,1:10]
        winter_output[8, 1,1:10]
        winter_output[9, 1,1:10]
        winter_output[10, 1,1:10]
        winter_output[9, 1,1:10]
        winter_output[8, 1,1:10]
        winter_output[0, 1,1:10]
        winter_output[0, 2,1:10]
        winter_output[1, 2,1:10]
        winter_output[6, 2,1:10]
        winter_index[1,1,1:10]
        winter_index[6,2,1:10]
        winter_index[6,1,1:10]
        winter_index[6,2,1:10]
        winter_output[6, 1,1:10]
ind1_population <- fread(paste(data_path, 'Population_1.csv', sep = ''))
ind1_population <- clean_up_indicator_1(ind1_population)
winter_h5$close_all()
Q
x <- c(1:9)
x
x
x <- c(1:12)
dim(x) <- c(3,4)
x
winter_h5$close_all()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create an empty list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # load an existing transition matrix # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram' x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
Q
source("initialise_hfd5.R")
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create an empty list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # load an existing transition matrix # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram' x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create an empty list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # load an existing transition matrix # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram' x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
c
c
index_space
Q
winter_h5$close_all()
x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
    winter_results <- run_model(strategy, params, cycles = strategy$cycles)
c
Q
winter_h5$close_all()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create an empty list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list() baseline_arglist$load_list('baseline_tmatrix') # load an existing transition matrix # baseline_arglist$edit_list() #Create the transition matrix baseline_matrix <- do.call(object_creator$define_transition, baseline_arglist$list_values()) # Create a list of model states state_list <- object_creator$create_states(state_names, a=x, b=y, c=z) # Initialise  cur_I <- NULL cur_CB <- NULL cur_CR <- NULL cur_EB <- NULL cur_ER <- NULL cur_ET <- NULL cur_KB <- NULL cur_KR <- NULL cur_KT <- NULL cur_SN <- NULL cur_SP <- NULL cur_POS <- NULL cur_PPC = NULL flow_cost <- rep(1,9) state_cost <- rep(10, 9) utility <- rep(1, 9) # Creates an unevaluated set of parameters parameters <- object_creator$define_parameters(I = get_I(cur_I),                                               CB = get_CB(cur_CB),                                               CR = get_CR(cur_CR,CB),                                               CT = (1 - CB - CR),                                               EB = get_EB(cur_EB),                                               ER = get_ER(cur_ER),                                               ET = get_ET(cur_ET),                                               KB = get_KB(cur_KB),                                               KR = get_KR(cur_KR),                                               KT = get_KT(cur_KT),                                               SN = get_testsn(cur_SN),                                               SP = get_testsp(cur_SP),                                               SW = .1                                               ) # Create and initialise inputs winter_input_dt <- ind1_population[, (state_names) := 0] winter_input_dt[ , NoBC := calculated_mean] # TODO - deparse the name of the arguments using (...) and create the property label. Test, treatment or xyz shouldn't # matter, e.g. s2_strategey$properties$... baseline_strategy <- object_creator$define_strategy(test = test,                                                     my_name = "baseline",                                                     cycles = 8,                                                     start_year = 2008,                                                     states = state_list,                                                     transition_matrix = baseline_matrix,                                                     parameters = parameters,                                                     dsa = NULL,                                                     mcmc = 'mcmc'                                                     ) # TODO - define_initialisation is extremely bespoke. More thought must be given to make it # a generic method class(baseline_strategy) start_year <- 2008 cycles <- 8 init <- winter_input_dt[l_period == baseline_strategy$start_year] test <- 'Mammogram' x <- mcmc_runner(strategy = baseline_strategy, n_accepted = 100)
    winter_results <- run_model(strategy, params, cycles = strategy$cycles)
c
winter_results
    winter_output <- winter_results[[1]][['output']]
    winter_index <- winter_results[[2]][['index']]
winter_output
winter_output[1,,]
winter_output[1,1,]
winter_output[1,1,1]
winter_output[,1,1]
winter_index
winter_index[,1,1]
winter_index[,,1]
        winter_output[, 1,1:10]
        winter_output[, 1,1]
Q
library(deSolve) # You first need to install this package if not already done ## Build an SIR model sir <- function(time, state, parameters) {     with(as.list(c(state, parameters)), {         dS <- -beta * S * I         dI <- beta * S * I - gamma * I         dR <- gamma * I         return(list(c(dS, dI, dR)))     }) } ## Just an example using the SIR model run_a_simulation <- function(parameters) {     ### Set parameters     init <- c(S = 1 - 1e-5, I = 1e-5, R = 0.0)     ## Time frame     times <- seq(0, 50, by = 0.1)     ## Solve using ode (General Solver for Ordinary Differential Equations)     out <- ode(y = init, times = times, func = sir, parms = parameters)     ## change to data frame     out <- as.data.frame(out)     return(out) } plot_results <- function(outputs) {     x11() # open a window for the plot     par(lwd = 3) # line-width option     plot(outputs$time, outputs$I, col = 'red', type = 'l', xlim = c(0, 50), ylim = c(0, 1), xlab = 'time', ylab = 'compartment proportions')     lines(outputs$time, outputs$S, col = 'green')     lines(outputs$time, outputs$R, col = 'blue') } metropolis_hastings <- function(log_lh_func, log_priors_func, proposal_func, init_params, n_accepted, max_iterations = 1e4) {     # log_lh_func: a function returning the log-likelihood value. This is log( P(data | theta) )     # priors_func: a function returning the joint prior log-likelihood of the parameters. This is  log( P(theta) )     # proposal_func (or jumping function): a function returning a new parameter set, starting from another parameter set. P(theta' | theta)     # init_params: a list containing the parameters. e.g list(beta=0.5, gamma=2.6)     # n_accepted: number of accepted runs     # max_iterations: maximum number of iterations allowed     # preliminary check: max_iterations has to be >= n_accepted     stopifnot(max_iterations >= n_accepted)     # prepare storage for the results. columns will be named "log_lh", "accepted", "param1", "param2", ...     results = data.frame(log_lh = double(), accepted = integer())     for (param_name in names(init_params)) {         results[[param_name]] = double()     }     # initialise counters     count_iterations = 0     count_accepted = 0     # calculate the likelihoods of the initial parameter set     current_params = init_params # current_params is the last accepted set of paramaters      current_log_lh = log_lh_func(init_params)     current_log_prior = log_priors_func(init_params)     while (count_accepted < n_accepted) {         if (count_iterations >= max_iterations) {             print("The maximum number of iterations has been reached. The simulation has been aborted.")             break         }         # Generate a new candidate parameter set         proposed_params = proposal_func(current_params)         # Evaluate the likelihood of the new parameter set         proposed_log_lh = log_lh_func(proposed_params)         proposed_log_prior = log_priors_func(proposed_params)         # Acceptance or rejection?         accepted = 0         log_proba_of_acceptance = proposed_log_prior + proposed_log_lh - (current_log_prior + current_log_lh) # we could have stored (current_log_prior + current_log_lh) in a variable         proba_of_acceptance = exp(log_proba_of_acceptance) # transform to actual proba         if (proba_of_acceptance >= 1) {             # the proposed parameter set is "better" than the current one             accepted = 1         } else {             accepted = rbinom(n = 1, size = 1, prob = proba_of_acceptance)         }         # storage         new_row = list(log_lh = proposed_log_lh + proposed_log_prior, accepted = accepted)         for (param_name in names(proposed_params)) {             new_row[[param_name]] = proposed_params[[param_name]]         }         results = rbind(results, new_row)         # If the run is accepted, we update the relevant variables         if (accepted == 1) {             current_params = proposed_params             current_log_prior = proposed_log_prior             current_log_lh = proposed_log_lh             count_accepted = count_accepted + 1         }         count_iterations = count_iterations + 1     }     # post-simulation calculation of acceptance ratio.      acceptance_ratio = count_accepted / count_iterations     print(paste('Acceptance ratio:', acceptance_ratio, sep = ' '))     return(results) } my_log_lh_func <- function(params) {     # params is a list of parameters and associated values.     # return the likelihood value associated with the parameter set.     # run the SIR model with the input parameters     sir_results = run_a_simulation((params))     # Our likelihood is obtained by multiplying Gaussian elements centered on the model estimate for each datapoint.     # We assume that the standard deviation is 0.05. This means that 95% of the Gaussian dentisty sits within an      # interval of width 0.1 (2*sd).     sd = 0.05     overall_log_lh = 0     for (i in 1:nrow(my_data)) {         # for each date of the dataset         model_output = sir_results$I[sir_results$time == my_data$date[i]]         browser()         single_log_lh = dnorm(x = my_data$in_bed[i], mean = model_output, sd = sd, log = TRUE)         overall_log_lh = overall_log_lh + single_log_lh     }     return(overall_log_lh) } my_log_priors_func <- function(params) {     # params is a list of parameters and associated values     # this funciton returns the joint prior distribution (actually log version)     joint_log_prior = 0     for (param_name in names(params)) {         if (param_name == "beta") {             # flat prior             y = dunif(x = params[[param_name]], min = 0, max = 10, log = TRUE)         } else if (param_name == "gamma") {             # beta distribution on interval [0,1]             y = dbeta(x = params[[param_name]], shape1 = 2, shape2 = 2, log = TRUE)         }         joint_log_prior = joint_log_prior + y     }     return(joint_log_prior) } my_proposal_func <- function(params) {     # params is a list of parameters and associated values     # this function returns another list of parameters     # We use normal distributions to generate new parameter values     # standard deviations     sd = list(beta = 0.02, gamma = 0.02)     new_params = list()     for (param_name in names(params)) {         new_value = -1         while (new_value < 0) {             # we want the parameter value to be positive             new_value = params[[param_name]] + rnorm(n = 1, mean = 0, sd = sd[[param_name]])         }         new_params[[param_name]] = new_value     }     return(new_params) } master_mcmc_runner <- function(n_accepted = 100) {     init_params = list(beta = 1.0, gamma = 0.5)     M = metropolis_hastings(log_lh_func = my_log_lh_func, log_priors_func = my_log_priors_func, proposal_func = my_proposal_func, init_params = init_params, n_accepted = n_accepted)     return(M) }
M = master_mcmc_runner(100)
library(outbreaks) # load outbreak datasets my_data = influenza_england_1978_school # influenza outbreak in a boarding school total_population = 763 # population of the boarding school # rearrange the data by turning dates into numbers my_data$date = as.numeric(my_data$date) # The index case (not included in the dataset) was infected on 10-01-1978. data starts on 22-01-1978 # Then the first date of the dataset will have index 12. adjustment = my_data$date[1] - 12 my_data$date = my_data$date - adjustment # normalise prevalence data my_data$in_bed = my_data$in_bed / total_population
M = master_mcmc_runner(100)
model_output
sir_results
my_data$date[i]
my_data$date
sir_results$time
my_data$date[i]
sir_results$I
sir_results$I[sir_results$time == my_data$date[i]]
my_data
my_data$in_bed[i]
? dnorm
Q
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create an empty list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list()
library(lazyeval) # required library(data.table) # required library(hdf5r) library(lhs) state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected') # create a HDF5 winter_h5 <- H5File$new("Winter.h5", mode = "w") # source files source("parameters.R") source("object creator.R") source("run_model.R") source("calculate_complement.R") source("perform_matrix_multiplication.R") source("get_state_counts.R") source("initialise_hfd5.R") source('load_data.R') source('mcmc.R') object_creator <- create_objects(state_names) #Create an empty list of values for the transition matrix baseline_arglist <- object_creator$create_argument_list()
library(lazyeval) # required
library(data.table) # required
library(hdf5r)
library(lhs)
state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected')
# create a HDF5
winter_h5 <- H5File$new("Winter.h5", mode = "w")
winter_h5$close_all()
winter_h5 <- H5File$new("Winter.h5", mode = "w")
source("parameters.R")
source("object creator.R")
source("object creator.R")
source("run_model.R")
source("calculate_complement.R")
source("perform_matrix_multiplication.R")
source("get_state_counts.R")
source("initialise_hfd5.R")
source('load_data.R')
source('mcmc.R')
object_creator <- create_objects(state_names)
#Create an empty list of values for the transition matrix
baseline_arglist <- object_creator$create_argument_list()
baseline_arglist$load_list('BASELINE.S1.TMKD')
baseline_arglist$edit_list()
baseline_arglist$update_list()
baseline_arglist <- object_creator$create_argument_list()
baseline_arglist$load_list('BASELINE.S1.TMKD')
baseline_arglist
baseline_arglist$list_values()
baseline_arglist$update_list()
baseline_arglist$edit_list()
baseline_arglist$edit_list()
baseline_arglist$list_values()
temp <- baseline_arglist$list_values()
temp$state.names
temp$state.names <- NULL
baseline_arglist$update_list(temp)
baseline_arglist <- object_creator$create_argument_list()
baseline_arglist$update_list(temp)
baseline_arglist$create_argument_list(temp)
baseline_arglist <- object_creator$create_argument_list(temp)
baseline_arglist <- object_creator$create_argument_list()
baseline_arglist$load_list('BASELINE.S1.TMKD')
temp <- baseline_arglist$list_values()
temp
temp$state.names <- NULL
dim(temp)
dim(temp) <- c(24,24)
temp
state_names <- c(1:24)
state_names
temp
baseline_arglist$update_list(temp)
len(temp)
length(temp)
length(state_names)
temp <- readRDS('BASELINE.S1.TMKD.rds')
temp <- readRDS('BASELINE.S1.TMKD')
temp <- readRDS('/Data/BASELINE.S1.TMKD.rds')
getcwd()
cwd()
gwd()
getwd()
temp <- readRDS('Data/BASELINE.S1.TMKD.rds')
temp
temp$state.names <-  NULL
temp
saveRDS(temp,'Data/BASELINE.S1.TMKD_1.rds')
baseline_arglist <- object_creator$create_argument_list()
baseline_arglist$load_list('baseline_tmatrix') # load an existing transition matrix
baseline_arglist <- object_creator$create_argument_list()
baseline_arglist$load_list('BASELINE.S1.TMKD_1')
baseline_arglist$edit_list()
baseline_arglist <- object_creator$create_argument_list()
baseline_arglist$load_list('baseline_tmatrix') # load an existing transition matrix
baseline_arglist$edit_list()
library(lazyeval) # required
library(data.table) # required
library(hdf5r)
library(lhs)
state_names <- c('NoBC', 'mild.b', 'mild.r', 'mild.t', 'prog.b', 'prog.r', 'prog.t',                   'scr.detected', 'cln.detected')
state_names <- c(1:24)
# create a HDF5
winter_h5 <- H5File$new("Winter.h5", mode = "w")
# source files
source("parameters.R")
source("object creator.R")
source("run_model.R")
source("calculate_complement.R")
source("perform_matrix_multiplication.R")
source("get_state_counts.R")
source("initialise_hfd5.R")
source('load_data.R')
source('mcmc.R')
object_creator <- create_objects(state_names)
baseline_arglist <- object_creator$create_argument_list('baseline')
baseline_arglist$edit_list()
baseline_arglist
baseline_arglist$list_values()
baseline_arglist <- object_creator$create_argument_list()
baseline_arglist$load_list('baseline') # load an existing transition matrix
baseline_arglist$edit_list()
baseline_arglist$load_list('s1') # load an existing transition matrix
baseline_arglist$edit_list()
baseline_arglist
baseline_arglist$list_values()
